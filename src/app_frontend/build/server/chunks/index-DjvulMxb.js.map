{"version":3,"file":"index-DjvulMxb.js","sources":["../../../../../node_modules/just-compare/index.mjs","../../../.svelte-kit/adapter-node/chunks/MapLibre.js","../../../../../node_modules/pmtiles/dist/index.js"],"sourcesContent":["var collectionCompare = compare;\n\n/*\n  primitives: value1 === value2\n  functions: value1.toString == value2.toString\n  arrays: if length, sequence and values of properties are identical\n  objects: if length, names and values of properties are identical\n  compare([[1, [2, 3]], [[1, [2, 3]]); // true\n  compare([[1, [2, 3], 4], [[1, [2, 3]]); // false\n  compare({a: 2, b: 3}, {a: 2, b: 3}); // true\n  compare({a: 2, b: 3}, {b: 3, a: 2}); // true\n  compare({a: 2, b: 3, c: 4}, {a: 2, b: 3}); // false\n  compare({a: 2, b: 3}, {a: 2, b: 3, c: 4}); // false\n  compare([[1, [2, {a: 4}], 4], [[1, [2, {a: 4}]]); // true\n*/\n\nfunction compare(value1, value2) {\n  if (value1 === value2) {\n    return true;\n  }\n\n  /* eslint-disable no-self-compare */\n  // if both values are NaNs return true\n  if (value1 !== value1 && value2 !== value2) {\n    return true;\n  }\n\n  if (\n    typeof value1 != typeof value2 || // primitive != primitive wrapper\n    {}.toString.call(value1) != {}.toString.call(value2) // check for other (maybe nullish) objects\n  ) {\n    return false;\n  }\n\n  if (value1 !== Object(value1)) {\n    // non equal primitives\n    return false;\n  }\n\n  if (!value1) {\n    return false;\n  }\n\n  if (Array.isArray(value1)) {\n    return compareArrays(value1, value2);\n  }\n\n  if ({}.toString.call(value1) == '[object Set]') {\n    return compareArrays(Array.from(value1), Array.from(value2));\n  }\n\n  if ({}.toString.call(value1) == '[object Object]') {\n    return compareObjects(value1, value2);\n  }\n\n  return compareNativeSubtypes(value1, value2);\n}\n\nfunction compareNativeSubtypes(value1, value2) {\n  // e.g. Function, RegExp, Date\n  return value1.toString() === value2.toString();\n}\n\nfunction compareArrays(value1, value2) {\n  var len = value1.length;\n\n  if (len != value2.length) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (!compare(value1[i], value2[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction compareObjects(value1, value2) {\n  var keys1 = Object.keys(value1);\n  var len = keys1.length;\n\n  if (len != Object.keys(value2).length) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    var key1 = keys1[i];\n\n    if (!(value2.hasOwnProperty(key1) && compare(value1[key1], value2[key1]))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport {collectionCompare as default};\n","import { q as getContext, s as setContext, v as fallback, t as store_get, u as unsubscribe_stores, x as bind_props, f as pop, p as push, w as store_set, m as attr, j as slot, n as stringify } from \"./index2.js\";\nimport \"just-flush\";\nimport { w as writable, r as readable } from \"./index.js\";\nimport maplibregl from \"maplibre-gl\";\nimport compare from \"just-compare\";\nimport { o as onDestroy } from \"./index-server.js\";\nimport { d as default_slot } from \"./misc.js\";\nconst MAP_CONTEXT_KEY = Symbol.for(\"svelte-maplibre\");\nfunction mapContext() {\n  return getContext(MAP_CONTEXT_KEY);\n}\nfunction eventTopMost(layerInfo) {\n  let tracker = /* @__PURE__ */ new WeakMap();\n  return (event) => {\n    let id = tracker.get(event.originalEvent);\n    if (id !== void 0) {\n      return id;\n    }\n    let features = event.target.queryRenderedFeatures(event.point);\n    let topId = features.find((f) => layerInfo.get(f.layer.id)?.interactive)?.layer.id;\n    tracker.set(event.originalEvent, topId);\n    return topId;\n  };\n}\nfunction createMapContext() {\n  let layerInfo = /* @__PURE__ */ new Map();\n  return setContext(MAP_CONTEXT_KEY, {\n    map: writable(null),\n    source: readable(null),\n    layer: readable(null),\n    popupTarget: readable(null),\n    cluster: writable(),\n    loadedImages: writable(/* @__PURE__ */ new Set()),\n    minzoom: writable(0),\n    maxzoom: writable(24),\n    layerEvent: writable(null),\n    layerInfo,\n    eventTopMost: eventTopMost(layerInfo),\n    markerClickManager: new MarkerClickManager()\n  });\n}\nfunction readableFromWritable(writable2) {\n  return {\n    subscribe: writable2.subscribe\n  };\n}\nfunction updatedContext({ key, setPopupTarget = false, setCluster = false, setMouseEvent = false }) {\n  let currentContext = mapContext();\n  let newValue = writable(null);\n  let ctxValue = readableFromWritable(newValue);\n  let newCtx = {\n    ...currentContext,\n    [key]: readableFromWritable(newValue)\n  };\n  if (setPopupTarget) {\n    newCtx.popupTarget = ctxValue;\n  }\n  if (setMouseEvent) {\n    let layerEvent = writable(null);\n    newCtx.layerEvent = layerEvent;\n    currentContext.layerEvent = layerEvent;\n  }\n  if (setCluster) {\n    newCtx.cluster = writable();\n  }\n  setContext(MAP_CONTEXT_KEY, newCtx);\n  return {\n    ...currentContext,\n    self: newValue\n  };\n}\nfunction updatedMarkerContext() {\n  return updatedContext({ key: \"popupTarget\", setPopupTarget: true, setMouseEvent: true });\n}\nfunction isDeckGlMouseEvent(event) {\n  return \"layerType\" in event && event.layerType === \"deckgl\";\n}\nclass MarkerClickManager {\n  _handlers = /* @__PURE__ */ new Set();\n  add(markerClickInfo) {\n    this._handlers.add(markerClickInfo);\n  }\n  remove(markerClickInfo) {\n    this._handlers.delete(markerClickInfo);\n  }\n  handleClick(event) {\n    for (const handler of this._handlers) {\n      handler(event);\n    }\n  }\n}\nfunction FullscreenControl($$payload, $$props) {\n  push();\n  var $$store_subs;\n  const { map } = mapContext();\n  let position = fallback($$props[\"position\"], \"top-left\");\n  let container = fallback($$props[\"container\"], () => void 0, true);\n  let control = null;\n  onDestroy(() => {\n    if (store_get($$store_subs ??= {}, \"$map\", map)?.loaded() && control) {\n      store_get($$store_subs ??= {}, \"$map\", map).removeControl(control);\n    }\n  });\n  if (store_get($$store_subs ??= {}, \"$map\", map) && !control) {\n    let containerEl;\n    if (typeof container === \"string\") {\n      containerEl = document.querySelector(container) ?? void 0;\n    } else {\n      containerEl = container;\n    }\n    control = new maplibregl.FullscreenControl({ container: containerEl });\n    store_get($$store_subs ??= {}, \"$map\", map).addControl(control, position);\n  }\n  if ($$store_subs) unsubscribe_stores($$store_subs);\n  bind_props($$props, { position, container });\n  pop();\n}\nfunction GeolocateControl($$payload, $$props) {\n  push();\n  var $$store_subs;\n  const { map } = mapContext();\n  let position = fallback($$props[\"position\"], \"top-left\");\n  let positionOptions = fallback($$props[\"positionOptions\"], () => void 0, true);\n  let fitBoundsOptions = fallback($$props[\"fitBoundsOptions\"], () => void 0, true);\n  let trackUserLocation = fallback($$props[\"trackUserLocation\"], false);\n  let showAccuracyCircle = fallback($$props[\"showAccuracyCircle\"], true);\n  let showUserLocation = fallback($$props[\"showUserLocation\"], true);\n  let control = fallback($$props[\"control\"], null);\n  onDestroy(() => {\n    if (store_get($$store_subs ??= {}, \"$map\", map)?.loaded() && control) {\n      store_get($$store_subs ??= {}, \"$map\", map).removeControl(control);\n    }\n  });\n  if (store_get($$store_subs ??= {}, \"$map\", map) && !control) {\n    control = new maplibregl.GeolocateControl({\n      positionOptions,\n      fitBoundsOptions,\n      trackUserLocation,\n      showAccuracyCircle,\n      showUserLocation\n    });\n    store_get($$store_subs ??= {}, \"$map\", map).addControl(control, position);\n  }\n  if ($$store_subs) unsubscribe_stores($$store_subs);\n  bind_props($$props, {\n    position,\n    positionOptions,\n    fitBoundsOptions,\n    trackUserLocation,\n    showAccuracyCircle,\n    showUserLocation,\n    control\n  });\n  pop();\n}\nfunction NavigationControl($$payload, $$props) {\n  push();\n  var $$store_subs;\n  const { map } = mapContext();\n  let position = fallback($$props[\"position\"], \"top-left\");\n  let showCompass = fallback($$props[\"showCompass\"], true);\n  let showZoom = fallback($$props[\"showZoom\"], true);\n  let visualizePitch = fallback($$props[\"visualizePitch\"], false);\n  let control = null;\n  onDestroy(() => {\n    if (store_get($$store_subs ??= {}, \"$map\", map)?.loaded() && control) {\n      store_get($$store_subs ??= {}, \"$map\", map).removeControl(control);\n    }\n  });\n  if (store_get($$store_subs ??= {}, \"$map\", map) && !control) {\n    control = new maplibregl.NavigationControl({ showCompass, showZoom, visualizePitch }), store_get($$store_subs ??= {}, \"$map\", map).addControl(control, position);\n  }\n  if ($$store_subs) unsubscribe_stores($$store_subs);\n  bind_props($$props, {\n    position,\n    showCompass,\n    showZoom,\n    visualizePitch\n  });\n  pop();\n}\nfunction ScaleControl($$payload, $$props) {\n  push();\n  var $$store_subs;\n  const { map } = mapContext();\n  let position = fallback($$props[\"position\"], \"bottom-left\");\n  let maxWidth = fallback($$props[\"maxWidth\"], () => void 0, true);\n  let unit = fallback($$props[\"unit\"], \"metric\");\n  let control = null;\n  onDestroy(() => {\n    if (store_get($$store_subs ??= {}, \"$map\", map)?.loaded() && control) {\n      store_get($$store_subs ??= {}, \"$map\", map).removeControl(control);\n    }\n  });\n  if (store_get($$store_subs ??= {}, \"$map\", map) && !control) {\n    control = new maplibregl.ScaleControl({ maxWidth, unit });\n    store_get($$store_subs ??= {}, \"$map\", map).addControl(control, position);\n  }\n  if ($$store_subs) unsubscribe_stores($$store_subs);\n  bind_props($$props, { position, maxWidth, unit });\n  pop();\n}\nfunction MapLibre($$payload, $$props) {\n  push();\n  var $$store_subs;\n  let standardControlsPosition, allImagesLoaded;\n  let map = fallback($$props[\"map\"], null);\n  let mapContainer = fallback($$props[\"mapContainer\"], () => void 0, true);\n  let classNames = fallback($$props[\"class\"], () => void 0, true);\n  let style = $$props[\"style\"];\n  let diffStyleUpdates = fallback($$props[\"diffStyleUpdates\"], false);\n  let center = fallback($$props[\"center\"], () => void 0, true);\n  let zoom = fallback($$props[\"zoom\"], () => void 0, true);\n  let pitch = fallback($$props[\"pitch\"], 0);\n  let bearing = fallback($$props[\"bearing\"], 0);\n  let bounds = fallback($$props[\"bounds\"], () => void 0, true);\n  let hash = fallback($$props[\"hash\"], false);\n  let updateHash = fallback($$props[\"updateHash\"], (url) => {\n    window.history.replaceState(window.history.state, \"\", url);\n  });\n  let loaded = fallback($$props[\"loaded\"], false);\n  let minZoom = fallback($$props[\"minZoom\"], 0);\n  let maxZoom = fallback($$props[\"maxZoom\"], 22);\n  let antialias = fallback($$props[\"antialias\"], () => void 0, true);\n  let zoomOnDoubleClick = fallback($$props[\"zoomOnDoubleClick\"], true);\n  let locale = fallback($$props[\"locale\"], () => void 0, true);\n  let interactive = fallback($$props[\"interactive\"], true);\n  let attributionControl = fallback($$props[\"attributionControl\"], true);\n  let cooperativeGestures = fallback($$props[\"cooperativeGestures\"], false);\n  let preserveDrawingBuffer = fallback($$props[\"preserveDrawingBuffer\"], false);\n  let maxBounds = fallback($$props[\"maxBounds\"], () => void 0, true);\n  let images = fallback($$props[\"images\"], () => [], true);\n  let standardControls = fallback($$props[\"standardControls\"], false);\n  let filterLayers = fallback($$props[\"filterLayers\"], () => void 0, true);\n  let transformRequest = fallback($$props[\"transformRequest\"], () => void 0, true);\n  const { map: mapInstance, loadedImages } = createMapContext();\n  let loadingImages = /* @__PURE__ */ new Set();\n  async function loadImage(image, force = false) {\n    if (!store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance)) {\n      return;\n    }\n    if (!store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance).loaded() && !force) {\n      return;\n    }\n    if (\"url\" in image) {\n      loadingImages.add(image.id);\n      try {\n        let imageData = await store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance).loadImage(image.url);\n        store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance)?.addImage(image.id, imageData.data, image.options);\n        store_get($$store_subs ??= {}, \"$loadedImages\", loadedImages).add(image.id);\n        store_set(loadedImages, store_get($$store_subs ??= {}, \"$loadedImages\", loadedImages));\n      } catch (e) {\n      } finally {\n        loadingImages.delete(image.id);\n      }\n    } else {\n      store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance).addImage(image.id, image.data, image.options);\n      store_get($$store_subs ??= {}, \"$loadedImages\", loadedImages).add(image.id);\n      store_set(loadedImages, store_get($$store_subs ??= {}, \"$loadedImages\", loadedImages));\n    }\n  }\n  let lastStyle = style;\n  standardControlsPosition = typeof standardControls === \"boolean\" ? void 0 : standardControls;\n  map = store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance);\n  if (store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance) && !compare(style, lastStyle)) {\n    store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance).getStyle();\n    lastStyle = style;\n    store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance).setStyle(style, { diff: diffStyleUpdates });\n    store_set(loadedImages, /* @__PURE__ */ new Set());\n    loadingImages = /* @__PURE__ */ new Set();\n  }\n  if (loaded && store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance)?.loaded()) {\n    for (let image of images) {\n      if (!store_get($$store_subs ??= {}, \"$loadedImages\", loadedImages).has(image.id) && !loadingImages.has(image.id) && !store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance).hasImage(image.id)) {\n        loadImage(image);\n      }\n    }\n  }\n  allImagesLoaded = images.every((image) => store_get($$store_subs ??= {}, \"$loadedImages\", loadedImages).has(image.id));\n  if (store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance)) {\n    let options = {};\n    if (center != null && !compare(center, store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance)?.getCenter())) {\n      options.center = center;\n    }\n    if (zoom != null && !compare(zoom, store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance)?.getZoom())) {\n      options.zoom = zoom;\n    }\n    if (bearing != null && !compare(bearing, store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance)?.getBearing())) {\n      options.bearing = bearing;\n    }\n    if (pitch != null && !compare(pitch, store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance)?.getPitch())) {\n      options.pitch = pitch;\n    }\n    if (Object.keys(options).length) {\n      store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance).easeTo(options);\n    }\n  }\n  if (bounds && !compare(bounds, store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance)?.getBounds())) store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance)?.fitBounds(bounds);\n  zoomOnDoubleClick ? store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance)?.doubleClickZoom.enable() : store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance)?.doubleClickZoom.disable();\n  $$payload.out += `<div${attr(\"class\", `${stringify(classNames)} svelte-p00lfq ${stringify([!classNames ? \"expand-map\" : \"\"].filter(Boolean).join(\" \"))}`)} data-testid=\"map-container\">`;\n  if (store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance) && loaded) {\n    $$payload.out += \"<!--[-->\";\n    if (standardControls) {\n      $$payload.out += \"<!--[-->\";\n      NavigationControl($$payload, { position: standardControlsPosition });\n      $$payload.out += `<!----> `;\n      GeolocateControl($$payload, {\n        position: standardControlsPosition,\n        fitBoundsOptions: { maxZoom: 12 }\n      });\n      $$payload.out += `<!----> `;\n      FullscreenControl($$payload, { position: standardControlsPosition });\n      $$payload.out += `<!----> `;\n      ScaleControl($$payload, { position: standardControlsPosition });\n      $$payload.out += `<!---->`;\n    } else {\n      $$payload.out += \"<!--[!-->\";\n    }\n    $$payload.out += `<!--]--> <!---->`;\n    slot(\n      $$payload,\n      default_slot($$props),\n      {\n        map: store_get($$store_subs ??= {}, \"$mapInstance\", mapInstance),\n        loadedImages: store_get($$store_subs ??= {}, \"$loadedImages\", loadedImages),\n        allImagesLoaded\n      }\n    );\n    $$payload.out += `<!---->`;\n  } else {\n    $$payload.out += \"<!--[!-->\";\n  }\n  $$payload.out += `<!--]--></div>`;\n  if ($$store_subs) unsubscribe_stores($$store_subs);\n  bind_props($$props, {\n    map,\n    mapContainer,\n    class: classNames,\n    style,\n    diffStyleUpdates,\n    center,\n    zoom,\n    pitch,\n    bearing,\n    bounds,\n    hash,\n    updateHash,\n    loaded,\n    minZoom,\n    maxZoom,\n    antialias,\n    zoomOnDoubleClick,\n    locale,\n    interactive,\n    attributionControl,\n    cooperativeGestures,\n    preserveDrawingBuffer,\n    maxBounds,\n    images,\n    standardControls,\n    filterLayers,\n    transformRequest\n  });\n  pop();\n}\nexport {\n  MapLibre as M,\n  isDeckGlMouseEvent as i,\n  mapContext as m,\n  updatedMarkerContext as u\n};\n","var __pow = Math.pow;\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// node_modules/fflate/esm/browser.js\nvar u8 = Uint8Array;\nvar u16 = Uint16Array;\nvar i32 = Int32Array;\nvar fleb = new u8([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  2,\n  2,\n  2,\n  2,\n  3,\n  3,\n  3,\n  3,\n  4,\n  4,\n  4,\n  4,\n  5,\n  5,\n  5,\n  5,\n  0,\n  /* unused */\n  0,\n  0,\n  /* impossible */\n  0\n]);\nvar fdeb = new u8([\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  2,\n  2,\n  3,\n  3,\n  4,\n  4,\n  5,\n  5,\n  6,\n  6,\n  7,\n  7,\n  8,\n  8,\n  9,\n  9,\n  10,\n  10,\n  11,\n  11,\n  12,\n  12,\n  13,\n  13,\n  /* unused */\n  0,\n  0\n]);\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\nvar freb = function(eb, start) {\n  var b = new u16(31);\n  for (var i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  }\n  var r = new i32(b[30]);\n  for (var i = 1; i < 30; ++i) {\n    for (var j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = j - b[i] << 5 | i;\n    }\n  }\n  return { b, r };\n};\nvar _a = freb(fleb, 2);\nvar fl = _a.b;\nvar revfl = _a.r;\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0);\nvar fd = _b.b;\nvar revfd = _b.r;\nvar rev = new u16(32768);\nfor (i = 0; i < 32768; ++i) {\n  x = (i & 43690) >> 1 | (i & 21845) << 1;\n  x = (x & 52428) >> 2 | (x & 13107) << 2;\n  x = (x & 61680) >> 4 | (x & 3855) << 4;\n  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n}\nvar x;\nvar i;\nvar hMap = function(cd, mb, r) {\n  var s = cd.length;\n  var i = 0;\n  var l = new u16(mb);\n  for (; i < s; ++i) {\n    if (cd[i])\n      ++l[cd[i] - 1];\n  }\n  var le = new u16(mb);\n  for (i = 1; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n  var co;\n  if (r) {\n    co = new u16(1 << mb);\n    var rvb = 15 - mb;\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        var sv = i << 4 | cd[i];\n        var r_1 = mb - cd[i];\n        var v = le[cd[i] - 1]++ << r_1;\n        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n          co[rev[v] >> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];\n      }\n    }\n  }\n  return co;\n};\nvar flt = new u8(288);\nfor (i = 0; i < 144; ++i)\n  flt[i] = 8;\nvar i;\nfor (i = 144; i < 256; ++i)\n  flt[i] = 9;\nvar i;\nfor (i = 256; i < 280; ++i)\n  flt[i] = 7;\nvar i;\nfor (i = 280; i < 288; ++i)\n  flt[i] = 8;\nvar i;\nvar fdt = new u8(32);\nfor (i = 0; i < 32; ++i)\n  fdt[i] = 5;\nvar i;\nvar flrm = /* @__PURE__ */ hMap(flt, 9, 1);\nvar fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\nvar max = function(a) {\n  var m = a[0];\n  for (var i = 1; i < a.length; ++i) {\n    if (a[i] > m)\n      m = a[i];\n  }\n  return m;\n};\nvar bits = function(d, p, m) {\n  var o = p / 8 | 0;\n  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\nvar bits16 = function(d, p) {\n  var o = p / 8 | 0;\n  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\nvar shft = function(p) {\n  return (p + 7) / 8 | 0;\n};\nvar slc = function(v, s, e) {\n  if (s == null || s < 0)\n    s = 0;\n  if (e == null || e > v.length)\n    e = v.length;\n  var n = new u8(e - s);\n  n.set(v.subarray(s, e));\n  return n;\n};\nvar ec = [\n  \"unexpected EOF\",\n  \"invalid block type\",\n  \"invalid length/literal\",\n  \"invalid distance\",\n  \"stream finished\",\n  \"no stream handler\",\n  ,\n  \"no callback\",\n  \"invalid UTF-8 data\",\n  \"extra field too long\",\n  \"date not in range 1980-2099\",\n  \"filename too long\",\n  \"stream finishing\",\n  \"invalid zip data\"\n  // determined by unknown compression method\n];\nvar err = function(ind, msg, nt) {\n  var e = new Error(msg || ec[ind]);\n  e.code = ind;\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(e, err);\n  if (!nt)\n    throw e;\n  return e;\n};\nvar inflt = function(dat, st, buf, dict) {\n  var sl = dat.length, dl = dict ? dict.length : 0;\n  if (!sl || st.f && !st.l)\n    return buf || new u8(0);\n  var noBuf = !buf || st.i != 2;\n  var noSt = st.i;\n  if (!buf)\n    buf = new u8(sl * 3);\n  var cbuf = function(l2) {\n    var bl = buf.length;\n    if (l2 > bl) {\n      var nbuf = new u8(Math.max(bl * 2, l2));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  };\n  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n  var tbts = sl * 8;\n  do {\n    if (!lm) {\n      final = bits(dat, pos, 1);\n      var type = bits(dat, pos + 1, 3);\n      pos += 3;\n      if (!type) {\n        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n        if (t > sl) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (noBuf)\n          cbuf(bt + l);\n        buf.set(dat.subarray(s, t), bt);\n        st.b = bt += l, st.p = pos = t * 8, st.f = final;\n        continue;\n      } else if (type == 1)\n        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n      else if (type == 2) {\n        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n        var tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14;\n        var ldt = new u8(tl);\n        var clt = new u8(19);\n        for (var i = 0; i < hcLen; ++i) {\n          clt[clim[i]] = bits(dat, pos + i * 3, 7);\n        }\n        pos += hcLen * 3;\n        var clb = max(clt), clbmsk = (1 << clb) - 1;\n        var clm = hMap(clt, clb, 1);\n        for (var i = 0; i < tl; ) {\n          var r = clm[bits(dat, pos, clbmsk)];\n          pos += r & 15;\n          var s = r >> 4;\n          if (s < 16) {\n            ldt[i++] = s;\n          } else {\n            var c = 0, n = 0;\n            if (s == 16)\n              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n            else if (s == 17)\n              n = 3 + bits(dat, pos, 7), pos += 3;\n            else if (s == 18)\n              n = 11 + bits(dat, pos, 127), pos += 7;\n            while (n--)\n              ldt[i++] = c;\n          }\n        }\n        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n        lbt = max(lt);\n        dbt = max(dt);\n        lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else\n        err(1);\n      if (pos > tbts) {\n        if (noSt)\n          err(0);\n        break;\n      }\n    }\n    if (noBuf)\n      cbuf(bt + 131072);\n    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n    var lpos = pos;\n    for (; ; lpos = pos) {\n      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n      pos += c & 15;\n      if (pos > tbts) {\n        if (noSt)\n          err(0);\n        break;\n      }\n      if (!c)\n        err(2);\n      if (sym < 256)\n        buf[bt++] = sym;\n      else if (sym == 256) {\n        lpos = pos, lm = null;\n        break;\n      } else {\n        var add = sym - 254;\n        if (sym > 264) {\n          var i = sym - 257, b = fleb[i];\n          add = bits(dat, pos, (1 << b) - 1) + fl[i];\n          pos += b;\n        }\n        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n        if (!d)\n          err(3);\n        pos += d & 15;\n        var dt = fd[dsym];\n        if (dsym > 3) {\n          var b = fdeb[dsym];\n          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n        }\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (noBuf)\n          cbuf(bt + 131072);\n        var end = bt + add;\n        if (bt < dt) {\n          var shift2 = dl - dt, dend = Math.min(dt, end);\n          if (shift2 + bt < 0)\n            err(3);\n          for (; bt < dend; ++bt)\n            buf[bt] = dict[shift2 + bt];\n        }\n        for (; bt < end; bt += 4) {\n          buf[bt] = buf[bt - dt];\n          buf[bt + 1] = buf[bt + 1 - dt];\n          buf[bt + 2] = buf[bt + 2 - dt];\n          buf[bt + 3] = buf[bt + 3 - dt];\n        }\n        bt = end;\n      }\n    }\n    st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n    if (lm)\n      final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final);\n  return bt == buf.length ? buf : slc(buf, 0, bt);\n};\nvar et = /* @__PURE__ */ new u8(0);\nvar gzs = function(d) {\n  if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n    err(6, \"invalid gzip data\");\n  var flg = d[3];\n  var st = 10;\n  if (flg & 4)\n    st += (d[10] | d[11] << 8) + 2;\n  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n    ;\n  return st + (flg & 2);\n};\nvar gzl = function(d) {\n  var l = d.length;\n  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\nvar zls = function(d, dict) {\n  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)\n    err(6, \"invalid zlib data\");\n  if ((d[1] >> 5 & 1) == +!dict)\n    err(6, \"invalid zlib data: \" + (d[1] & 32 ? \"need\" : \"unexpected\") + \" dictionary\");\n  return (d[1] >> 3 & 4) + 2;\n};\nfunction inflateSync(data, opts) {\n  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\nfunction gunzipSync(data, opts) {\n  var st = gzs(data);\n  if (st + 8 > data.length)\n    err(6, \"invalid gzip data\");\n  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\nfunction unzlibSync(data, opts) {\n  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\nfunction decompressSync(data, opts) {\n  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);\n}\nvar td = typeof TextDecoder != \"undefined\" && /* @__PURE__ */ new TextDecoder();\nvar tds = 0;\ntry {\n  td.decode(et, { stream: true });\n  tds = 1;\n} catch (e) {\n}\n\n// v2.ts\nvar shift = (n, shift2) => {\n  return n * __pow(2, shift2);\n};\nvar unshift = (n, shift2) => {\n  return Math.floor(n / __pow(2, shift2));\n};\nvar getUint24 = (view, pos) => {\n  return shift(view.getUint16(pos + 1, true), 8) + view.getUint8(pos);\n};\nvar getUint48 = (view, pos) => {\n  return shift(view.getUint32(pos + 2, true), 16) + view.getUint16(pos, true);\n};\nvar compare = (tz, tx, ty, view, i) => {\n  if (tz !== view.getUint8(i))\n    return tz - view.getUint8(i);\n  const x = getUint24(view, i + 1);\n  if (tx !== x)\n    return tx - x;\n  const y = getUint24(view, i + 4);\n  if (ty !== y)\n    return ty - y;\n  return 0;\n};\nvar queryLeafdir = (view, z, x, y) => {\n  const offsetLen = queryView(view, z | 128, x, y);\n  if (offsetLen) {\n    return {\n      z,\n      x,\n      y,\n      offset: offsetLen[0],\n      length: offsetLen[1],\n      isDir: true\n    };\n  }\n  return null;\n};\nvar queryTile = (view, z, x, y) => {\n  const offsetLen = queryView(view, z, x, y);\n  if (offsetLen) {\n    return {\n      z,\n      x,\n      y,\n      offset: offsetLen[0],\n      length: offsetLen[1],\n      isDir: false\n    };\n  }\n  return null;\n};\nvar queryView = (view, z, x, y) => {\n  let m = 0;\n  let n = view.byteLength / 17 - 1;\n  while (m <= n) {\n    const k = n + m >> 1;\n    const cmp = compare(z, x, y, view, k * 17);\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return [getUint48(view, k * 17 + 7), view.getUint32(k * 17 + 13, true)];\n    }\n  }\n  return null;\n};\nvar entrySort = (a, b) => {\n  if (a.isDir && !b.isDir) {\n    return 1;\n  }\n  if (!a.isDir && b.isDir) {\n    return -1;\n  }\n  if (a.z !== b.z) {\n    return a.z - b.z;\n  }\n  if (a.x !== b.x) {\n    return a.x - b.x;\n  }\n  return a.y - b.y;\n};\nvar parseEntry = (dataview, i) => {\n  const zRaw = dataview.getUint8(i * 17);\n  const z = zRaw & 127;\n  return {\n    z,\n    x: getUint24(dataview, i * 17 + 1),\n    y: getUint24(dataview, i * 17 + 4),\n    offset: getUint48(dataview, i * 17 + 7),\n    length: dataview.getUint32(i * 17 + 13, true),\n    isDir: zRaw >> 7 === 1\n  };\n};\nvar sortDir = (a) => {\n  const entries = [];\n  const view = new DataView(a);\n  for (let i = 0; i < view.byteLength / 17; i++) {\n    entries.push(parseEntry(view, i));\n  }\n  return createDirectory(entries);\n};\nvar createDirectory = (entries) => {\n  entries.sort(entrySort);\n  const buffer = new ArrayBuffer(17 * entries.length);\n  const arr = new Uint8Array(buffer);\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i];\n    let z = entry.z;\n    if (entry.isDir)\n      z = z | 128;\n    arr[i * 17] = z;\n    arr[i * 17 + 1] = entry.x & 255;\n    arr[i * 17 + 2] = entry.x >> 8 & 255;\n    arr[i * 17 + 3] = entry.x >> 16 & 255;\n    arr[i * 17 + 4] = entry.y & 255;\n    arr[i * 17 + 5] = entry.y >> 8 & 255;\n    arr[i * 17 + 6] = entry.y >> 16 & 255;\n    arr[i * 17 + 7] = entry.offset & 255;\n    arr[i * 17 + 8] = unshift(entry.offset, 8) & 255;\n    arr[i * 17 + 9] = unshift(entry.offset, 16) & 255;\n    arr[i * 17 + 10] = unshift(entry.offset, 24) & 255;\n    arr[i * 17 + 11] = unshift(entry.offset, 32) & 255;\n    arr[i * 17 + 12] = unshift(entry.offset, 48) & 255;\n    arr[i * 17 + 13] = entry.length & 255;\n    arr[i * 17 + 14] = entry.length >> 8 & 255;\n    arr[i * 17 + 15] = entry.length >> 16 & 255;\n    arr[i * 17 + 16] = entry.length >> 24 & 255;\n  }\n  return buffer;\n};\nvar deriveLeaf = (view, tile) => {\n  if (view.byteLength < 17)\n    return null;\n  const numEntries = view.byteLength / 17;\n  const entry = parseEntry(view, numEntries - 1);\n  if (entry.isDir) {\n    const leafLevel = entry.z;\n    const levelDiff = tile.z - leafLevel;\n    const leafX = Math.trunc(tile.x / (1 << levelDiff));\n    const leafY = Math.trunc(tile.y / (1 << levelDiff));\n    return { z: leafLevel, x: leafX, y: leafY };\n  }\n  return null;\n};\nfunction getHeader(source) {\n  return __async(this, null, function* () {\n    const resp = yield source.getBytes(0, 512e3);\n    const dataview = new DataView(resp.data);\n    const jsonSize = dataview.getUint32(4, true);\n    const rootEntries = dataview.getUint16(8, true);\n    const dec = new TextDecoder(\"utf-8\");\n    const jsonMetadata = JSON.parse(\n      dec.decode(new DataView(resp.data, 10, jsonSize))\n    );\n    let tileCompression = 0 /* Unknown */;\n    if (jsonMetadata.compression === \"gzip\") {\n      tileCompression = 2 /* Gzip */;\n    }\n    let minzoom = 0;\n    if (\"minzoom\" in jsonMetadata) {\n      minzoom = +jsonMetadata.minzoom;\n    }\n    let maxzoom = 0;\n    if (\"maxzoom\" in jsonMetadata) {\n      maxzoom = +jsonMetadata.maxzoom;\n    }\n    let centerLon = 0;\n    let centerLat = 0;\n    let centerZoom = 0;\n    let minLon = -180;\n    let minLat = -85;\n    let maxLon = 180;\n    let maxLat = 85;\n    if (jsonMetadata.bounds) {\n      const split = jsonMetadata.bounds.split(\",\");\n      minLon = +split[0];\n      minLat = +split[1];\n      maxLon = +split[2];\n      maxLat = +split[3];\n    }\n    if (jsonMetadata.center) {\n      const split = jsonMetadata.center.split(\",\");\n      centerLon = +split[0];\n      centerLat = +split[1];\n      centerZoom = +split[2];\n    }\n    const header = {\n      specVersion: dataview.getUint16(2, true),\n      rootDirectoryOffset: 10 + jsonSize,\n      rootDirectoryLength: rootEntries * 17,\n      jsonMetadataOffset: 10,\n      jsonMetadataLength: jsonSize,\n      leafDirectoryOffset: 0,\n      leafDirectoryLength: void 0,\n      tileDataOffset: 0,\n      tileDataLength: void 0,\n      numAddressedTiles: 0,\n      numTileEntries: 0,\n      numTileContents: 0,\n      clustered: false,\n      internalCompression: 1 /* None */,\n      tileCompression,\n      tileType: 1 /* Mvt */,\n      minZoom: minzoom,\n      maxZoom: maxzoom,\n      minLon,\n      minLat,\n      maxLon,\n      maxLat,\n      centerZoom,\n      centerLon,\n      centerLat,\n      etag: resp.etag\n    };\n    return header;\n  });\n}\nfunction getZxy(header, source, cache, z, x, y, signal) {\n  return __async(this, null, function* () {\n    let rootDir = yield cache.getArrayBuffer(\n      source,\n      header.rootDirectoryOffset,\n      header.rootDirectoryLength,\n      header\n    );\n    if (header.specVersion === 1) {\n      rootDir = sortDir(rootDir);\n    }\n    const entry = queryTile(new DataView(rootDir), z, x, y);\n    if (entry) {\n      const resp = yield source.getBytes(entry.offset, entry.length, signal);\n      let tileData = resp.data;\n      const view = new DataView(tileData);\n      if (view.getUint8(0) === 31 && view.getUint8(1) === 139) {\n        tileData = decompressSync(new Uint8Array(tileData));\n      }\n      return {\n        data: tileData\n      };\n    }\n    const leafcoords = deriveLeaf(new DataView(rootDir), { z, x, y });\n    if (leafcoords) {\n      const leafdirEntry = queryLeafdir(\n        new DataView(rootDir),\n        leafcoords.z,\n        leafcoords.x,\n        leafcoords.y\n      );\n      if (leafdirEntry) {\n        let leafDir = yield cache.getArrayBuffer(\n          source,\n          leafdirEntry.offset,\n          leafdirEntry.length,\n          header\n        );\n        if (header.specVersion === 1) {\n          leafDir = sortDir(leafDir);\n        }\n        const tileEntry = queryTile(new DataView(leafDir), z, x, y);\n        if (tileEntry) {\n          const resp = yield source.getBytes(\n            tileEntry.offset,\n            tileEntry.length,\n            signal\n          );\n          let tileData = resp.data;\n          const view = new DataView(tileData);\n          if (view.getUint8(0) === 31 && view.getUint8(1) === 139) {\n            tileData = decompressSync(new Uint8Array(tileData));\n          }\n          return {\n            data: tileData\n          };\n        }\n      }\n    }\n    return void 0;\n  });\n}\nvar v2_default = {\n  getHeader,\n  getZxy\n};\n\n// adapters.ts\nvar leafletRasterLayer = (source, options) => {\n  let loaded = false;\n  let mimeType = \"\";\n  const cls = L.GridLayer.extend({\n    createTile: (coord, done) => {\n      const el = document.createElement(\"img\");\n      const controller = new AbortController();\n      const signal = controller.signal;\n      el.cancel = () => {\n        controller.abort();\n      };\n      if (!loaded) {\n        source.getHeader().then((header) => {\n          if (header.tileType === 1 /* Mvt */) {\n            console.error(\n              \"Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.\"\n            );\n          } else if (header.tileType === 2) {\n            mimeType = \"image/png\";\n          } else if (header.tileType === 3) {\n            mimeType = \"image/jpeg\";\n          } else if (header.tileType === 4) {\n            mimeType = \"image/webp\";\n          } else if (header.tileType === 5) {\n            mimeType = \"image/avif\";\n          }\n        });\n        loaded = true;\n      }\n      source.getZxy(coord.z, coord.x, coord.y, signal).then((arr) => {\n        if (arr) {\n          const blob = new Blob([arr.data], { type: mimeType });\n          const imageUrl = window.URL.createObjectURL(blob);\n          el.src = imageUrl;\n          el.cancel = void 0;\n          done(void 0, el);\n        }\n      }).catch((e) => {\n        if (e.name !== \"AbortError\") {\n          throw e;\n        }\n      });\n      return el;\n    },\n    _removeTile: function(key) {\n      const tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n      if (tile.el.cancel)\n        tile.el.cancel();\n      tile.el.width = 0;\n      tile.el.height = 0;\n      tile.el.deleted = true;\n      L.DomUtil.remove(tile.el);\n      delete this._tiles[key];\n      this.fire(\"tileunload\", {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key)\n      });\n    }\n  });\n  return new cls(options);\n};\nvar v3compat = (v4) => (requestParameters, arg2) => {\n  if (arg2 instanceof AbortController) {\n    return v4(requestParameters, arg2);\n  }\n  const abortController = new AbortController();\n  v4(requestParameters, abortController).then(\n    (result) => {\n      return arg2(\n        void 0,\n        result.data,\n        result.cacheControl || \"\",\n        result.expires || \"\"\n      );\n    },\n    (err2) => {\n      return arg2(err2);\n    }\n  ).catch((e) => {\n    return arg2(e);\n  });\n  return { cancel: () => abortController.abort() };\n};\nvar Protocol = class {\n  constructor() {\n    this.tilev4 = (params, abortController) => __async(this, null, function* () {\n      if (params.type === \"json\") {\n        const pmtilesUrl2 = params.url.substr(10);\n        let instance2 = this.tiles.get(pmtilesUrl2);\n        if (!instance2) {\n          instance2 = new PMTiles(pmtilesUrl2);\n          this.tiles.set(pmtilesUrl2, instance2);\n        }\n        const h = yield instance2.getHeader();\n        return {\n          data: {\n            tiles: [`${params.url}/{z}/{x}/{y}`],\n            minzoom: h.minZoom,\n            maxzoom: h.maxZoom,\n            bounds: [h.minLon, h.minLat, h.maxLon, h.maxLat]\n          }\n        };\n      }\n      const re = new RegExp(/pmtiles:\\/\\/(.+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/);\n      const result = params.url.match(re);\n      if (!result) {\n        throw new Error(\"Invalid PMTiles protocol URL\");\n      }\n      const pmtilesUrl = result[1];\n      let instance = this.tiles.get(pmtilesUrl);\n      if (!instance) {\n        instance = new PMTiles(pmtilesUrl);\n        this.tiles.set(pmtilesUrl, instance);\n      }\n      const z = result[2];\n      const x = result[3];\n      const y = result[4];\n      const header = yield instance.getHeader();\n      const resp = yield instance == null ? void 0 : instance.getZxy(+z, +x, +y, abortController.signal);\n      if (resp) {\n        return {\n          data: new Uint8Array(resp.data),\n          cacheControl: resp.cacheControl,\n          expires: resp.expires\n        };\n      }\n      if (header.tileType === 1 /* Mvt */) {\n        return { data: new Uint8Array() };\n      }\n      return { data: null };\n    });\n    this.tile = v3compat(this.tilev4);\n    this.tiles = /* @__PURE__ */ new Map();\n  }\n  add(p) {\n    this.tiles.set(p.source.getKey(), p);\n  }\n  get(url) {\n    return this.tiles.get(url);\n  }\n};\n\n// index.ts\nfunction toNum(low, high) {\n  return (high >>> 0) * 4294967296 + (low >>> 0);\n}\nfunction readVarintRemainder(l, p) {\n  const buf = p.buf;\n  let b = buf[p.pos++];\n  let h = (b & 112) >> 4;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 127) << 3;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 127) << 10;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 127) << 17;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 127) << 24;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 1) << 31;\n  if (b < 128)\n    return toNum(l, h);\n  throw new Error(\"Expected varint not more than 10 bytes\");\n}\nfunction readVarint(p) {\n  const buf = p.buf;\n  let b = buf[p.pos++];\n  let val = b & 127;\n  if (b < 128)\n    return val;\n  b = buf[p.pos++];\n  val |= (b & 127) << 7;\n  if (b < 128)\n    return val;\n  b = buf[p.pos++];\n  val |= (b & 127) << 14;\n  if (b < 128)\n    return val;\n  b = buf[p.pos++];\n  val |= (b & 127) << 21;\n  if (b < 128)\n    return val;\n  b = buf[p.pos];\n  val |= (b & 15) << 28;\n  return readVarintRemainder(val, p);\n}\nfunction rotate(n, xy, rx, ry) {\n  if (ry === 0) {\n    if (rx === 1) {\n      xy[0] = n - 1 - xy[0];\n      xy[1] = n - 1 - xy[1];\n    }\n    const t = xy[0];\n    xy[0] = xy[1];\n    xy[1] = t;\n  }\n}\nfunction idOnLevel(z, pos) {\n  const n = __pow(2, z);\n  let rx = pos;\n  let ry = pos;\n  let t = pos;\n  const xy = [0, 0];\n  let s = 1;\n  while (s < n) {\n    rx = 1 & t / 2;\n    ry = 1 & (t ^ rx);\n    rotate(s, xy, rx, ry);\n    xy[0] += s * rx;\n    xy[1] += s * ry;\n    t = t / 4;\n    s *= 2;\n  }\n  return [z, xy[0], xy[1]];\n}\nvar tzValues = [\n  0,\n  1,\n  5,\n  21,\n  85,\n  341,\n  1365,\n  5461,\n  21845,\n  87381,\n  349525,\n  1398101,\n  5592405,\n  22369621,\n  89478485,\n  357913941,\n  1431655765,\n  5726623061,\n  22906492245,\n  91625968981,\n  366503875925,\n  1466015503701,\n  5864062014805,\n  23456248059221,\n  93824992236885,\n  375299968947541,\n  1501199875790165\n];\nfunction zxyToTileId(z, x, y) {\n  if (z > 26) {\n    throw Error(\"Tile zoom level exceeds max safe number limit (26)\");\n  }\n  if (x > __pow(2, z) - 1 || y > __pow(2, z) - 1) {\n    throw Error(\"tile x/y outside zoom level bounds\");\n  }\n  const acc = tzValues[z];\n  const n = __pow(2, z);\n  let rx = 0;\n  let ry = 0;\n  let d = 0;\n  const xy = [x, y];\n  let s = n / 2;\n  while (s > 0) {\n    rx = (xy[0] & s) > 0 ? 1 : 0;\n    ry = (xy[1] & s) > 0 ? 1 : 0;\n    d += s * s * (3 * rx ^ ry);\n    rotate(s, xy, rx, ry);\n    s = s / 2;\n  }\n  return acc + d;\n}\nfunction tileIdToZxy(i) {\n  let acc = 0;\n  const z = 0;\n  for (let z2 = 0; z2 < 27; z2++) {\n    const numTiles = (1 << z2) * (1 << z2);\n    if (acc + numTiles > i) {\n      return idOnLevel(z2, i - acc);\n    }\n    acc += numTiles;\n  }\n  throw Error(\"Tile zoom level exceeds max safe number limit (26)\");\n}\nvar Compression = /* @__PURE__ */ ((Compression2) => {\n  Compression2[Compression2[\"Unknown\"] = 0] = \"Unknown\";\n  Compression2[Compression2[\"None\"] = 1] = \"None\";\n  Compression2[Compression2[\"Gzip\"] = 2] = \"Gzip\";\n  Compression2[Compression2[\"Brotli\"] = 3] = \"Brotli\";\n  Compression2[Compression2[\"Zstd\"] = 4] = \"Zstd\";\n  return Compression2;\n})(Compression || {});\nfunction defaultDecompress(buf, compression) {\n  return __async(this, null, function* () {\n    if (compression === 1 /* None */ || compression === 0 /* Unknown */) {\n      return buf;\n    }\n    if (compression === 2 /* Gzip */) {\n      if (typeof globalThis.DecompressionStream === \"undefined\") {\n        return decompressSync(new Uint8Array(buf));\n      }\n      const stream = new Response(buf).body;\n      if (!stream) {\n        throw Error(\"Failed to read response stream\");\n      }\n      const result = stream.pipeThrough(\n        // biome-ignore lint: needed to detect DecompressionStream in browser+node+cloudflare workers\n        new globalThis.DecompressionStream(\"gzip\")\n      );\n      return new Response(result).arrayBuffer();\n    }\n    throw Error(\"Compression method not supported\");\n  });\n}\nvar TileType = /* @__PURE__ */ ((TileType2) => {\n  TileType2[TileType2[\"Unknown\"] = 0] = \"Unknown\";\n  TileType2[TileType2[\"Mvt\"] = 1] = \"Mvt\";\n  TileType2[TileType2[\"Png\"] = 2] = \"Png\";\n  TileType2[TileType2[\"Jpeg\"] = 3] = \"Jpeg\";\n  TileType2[TileType2[\"Webp\"] = 4] = \"Webp\";\n  TileType2[TileType2[\"Avif\"] = 5] = \"Avif\";\n  return TileType2;\n})(TileType || {});\nvar HEADER_SIZE_BYTES = 127;\nfunction findTile(entries, tileId) {\n  let m = 0;\n  let n = entries.length - 1;\n  while (m <= n) {\n    const k = n + m >> 1;\n    const cmp = tileId - entries[k].tileId;\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return entries[k];\n    }\n  }\n  if (n >= 0) {\n    if (entries[n].runLength === 0) {\n      return entries[n];\n    }\n    if (tileId - entries[n].tileId < entries[n].runLength) {\n      return entries[n];\n    }\n  }\n  return null;\n}\nvar FileSource = class {\n  constructor(file) {\n    this.file = file;\n  }\n  getKey() {\n    return this.file.name;\n  }\n  getBytes(offset, length) {\n    return __async(this, null, function* () {\n      const blob = this.file.slice(offset, offset + length);\n      const a = yield blob.arrayBuffer();\n      return { data: a };\n    });\n  }\n};\nvar FetchSource = class {\n  constructor(url, customHeaders = new Headers()) {\n    this.url = url;\n    this.customHeaders = customHeaders;\n    this.mustReload = false;\n  }\n  getKey() {\n    return this.url;\n  }\n  setHeaders(customHeaders) {\n    this.customHeaders = customHeaders;\n  }\n  getBytes(offset, length, passedSignal, etag) {\n    return __async(this, null, function* () {\n      let controller;\n      let signal;\n      if (passedSignal) {\n        signal = passedSignal;\n      } else {\n        controller = new AbortController();\n        signal = controller.signal;\n      }\n      const requestHeaders = new Headers(this.customHeaders);\n      requestHeaders.set(\"range\", `bytes=${offset}-${offset + length - 1}`);\n      let cache;\n      if (this.mustReload) {\n        cache = \"reload\";\n      }\n      let resp = yield fetch(this.url, {\n        signal,\n        cache,\n        headers: requestHeaders\n        //biome-ignore lint: \"cache\" is incompatible between cloudflare workers and browser\n      });\n      if (offset === 0 && resp.status === 416) {\n        const contentRange = resp.headers.get(\"Content-Range\");\n        if (!contentRange || !contentRange.startsWith(\"bytes */\")) {\n          throw Error(\"Missing content-length on 416 response\");\n        }\n        const actualLength = +contentRange.substr(8);\n        resp = yield fetch(this.url, {\n          signal,\n          cache: \"reload\",\n          headers: { range: `bytes=0-${actualLength - 1}` }\n          //biome-ignore lint: \"cache\" is incompatible between cloudflare workers and browser\n        });\n      }\n      let newEtag = resp.headers.get(\"Etag\");\n      if (newEtag == null ? void 0 : newEtag.startsWith(\"W/\")) {\n        newEtag = null;\n      }\n      if (resp.status === 416 || etag && newEtag && newEtag !== etag) {\n        this.mustReload = true;\n        throw new EtagMismatch(\n          `Server returned non-matching ETag ${etag} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`\n        );\n      }\n      if (resp.status >= 300) {\n        throw Error(`Bad response code: ${resp.status}`);\n      }\n      const contentLength = resp.headers.get(\"Content-Length\");\n      if (resp.status === 200 && (!contentLength || +contentLength > length)) {\n        if (controller)\n          controller.abort();\n        throw Error(\n          \"Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.\"\n        );\n      }\n      const a = yield resp.arrayBuffer();\n      return {\n        data: a,\n        etag: newEtag || void 0,\n        cacheControl: resp.headers.get(\"Cache-Control\") || void 0,\n        expires: resp.headers.get(\"Expires\") || void 0\n      };\n    });\n  }\n};\nfunction getUint64(v, offset) {\n  const wh = v.getUint32(offset + 4, true);\n  const wl = v.getUint32(offset + 0, true);\n  return wh * __pow(2, 32) + wl;\n}\nfunction bytesToHeader(bytes, etag) {\n  const v = new DataView(bytes);\n  const specVersion = v.getUint8(7);\n  if (specVersion > 3) {\n    throw Error(\n      `Archive is spec version ${specVersion} but this library supports up to spec version 3`\n    );\n  }\n  return {\n    specVersion,\n    rootDirectoryOffset: getUint64(v, 8),\n    rootDirectoryLength: getUint64(v, 16),\n    jsonMetadataOffset: getUint64(v, 24),\n    jsonMetadataLength: getUint64(v, 32),\n    leafDirectoryOffset: getUint64(v, 40),\n    leafDirectoryLength: getUint64(v, 48),\n    tileDataOffset: getUint64(v, 56),\n    tileDataLength: getUint64(v, 64),\n    numAddressedTiles: getUint64(v, 72),\n    numTileEntries: getUint64(v, 80),\n    numTileContents: getUint64(v, 88),\n    clustered: v.getUint8(96) === 1,\n    internalCompression: v.getUint8(97),\n    tileCompression: v.getUint8(98),\n    tileType: v.getUint8(99),\n    minZoom: v.getUint8(100),\n    maxZoom: v.getUint8(101),\n    minLon: v.getInt32(102, true) / 1e7,\n    minLat: v.getInt32(106, true) / 1e7,\n    maxLon: v.getInt32(110, true) / 1e7,\n    maxLat: v.getInt32(114, true) / 1e7,\n    centerZoom: v.getUint8(118),\n    centerLon: v.getInt32(119, true) / 1e7,\n    centerLat: v.getInt32(123, true) / 1e7,\n    etag\n  };\n}\nfunction deserializeIndex(buffer) {\n  const p = { buf: new Uint8Array(buffer), pos: 0 };\n  const numEntries = readVarint(p);\n  const entries = [];\n  let lastId = 0;\n  for (let i = 0; i < numEntries; i++) {\n    const v = readVarint(p);\n    entries.push({ tileId: lastId + v, offset: 0, length: 0, runLength: 1 });\n    lastId += v;\n  }\n  for (let i = 0; i < numEntries; i++) {\n    entries[i].runLength = readVarint(p);\n  }\n  for (let i = 0; i < numEntries; i++) {\n    entries[i].length = readVarint(p);\n  }\n  for (let i = 0; i < numEntries; i++) {\n    const v = readVarint(p);\n    if (v === 0 && i > 0) {\n      entries[i].offset = entries[i - 1].offset + entries[i - 1].length;\n    } else {\n      entries[i].offset = v - 1;\n    }\n  }\n  return entries;\n}\nfunction detectVersion(a) {\n  const v = new DataView(a);\n  if (v.getUint16(2, true) === 2) {\n    console.warn(\n      \"PMTiles spec version 2 has been deprecated; please see github.com/protomaps/PMTiles for tools to upgrade\"\n    );\n    return 2;\n  }\n  if (v.getUint16(2, true) === 1) {\n    console.warn(\n      \"PMTiles spec version 1 has been deprecated; please see github.com/protomaps/PMTiles for tools to upgrade\"\n    );\n    return 1;\n  }\n  return 3;\n}\nvar EtagMismatch = class extends Error {\n};\nfunction getHeaderAndRoot(source, decompress) {\n  return __async(this, null, function* () {\n    const resp = yield source.getBytes(0, 16384);\n    const v = new DataView(resp.data);\n    if (v.getUint16(0, true) !== 19792) {\n      throw new Error(\"Wrong magic number for PMTiles archive\");\n    }\n    if (detectVersion(resp.data) < 3) {\n      return [yield v2_default.getHeader(source)];\n    }\n    const headerData = resp.data.slice(0, HEADER_SIZE_BYTES);\n    const header = bytesToHeader(headerData, resp.etag);\n    const rootDirData = resp.data.slice(\n      header.rootDirectoryOffset,\n      header.rootDirectoryOffset + header.rootDirectoryLength\n    );\n    const dirKey = `${source.getKey()}|${header.etag || \"\"}|${header.rootDirectoryOffset}|${header.rootDirectoryLength}`;\n    const rootDir = deserializeIndex(\n      yield decompress(rootDirData, header.internalCompression)\n    );\n    return [header, [dirKey, rootDir.length, rootDir]];\n  });\n}\nfunction getDirectory(source, decompress, offset, length, header) {\n  return __async(this, null, function* () {\n    const resp = yield source.getBytes(offset, length, void 0, header.etag);\n    const data = yield decompress(resp.data, header.internalCompression);\n    const directory = deserializeIndex(data);\n    if (directory.length === 0) {\n      throw new Error(\"Empty directory is invalid\");\n    }\n    return directory;\n  });\n}\nvar ResolvedValueCache = class {\n  constructor(maxCacheEntries = 100, prefetch = true, decompress = defaultDecompress) {\n    this.cache = /* @__PURE__ */ new Map();\n    this.maxCacheEntries = maxCacheEntries;\n    this.counter = 1;\n    this.decompress = decompress;\n  }\n  getHeader(source) {\n    return __async(this, null, function* () {\n      const cacheKey = source.getKey();\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = cacheValue.data;\n        return data;\n      }\n      const res = yield getHeaderAndRoot(source, this.decompress);\n      if (res[1]) {\n        this.cache.set(res[1][0], {\n          lastUsed: this.counter++,\n          data: res[1][2]\n        });\n      }\n      this.cache.set(cacheKey, {\n        lastUsed: this.counter++,\n        data: res[0]\n      });\n      this.prune();\n      return res[0];\n    });\n  }\n  getDirectory(source, offset, length, header) {\n    return __async(this, null, function* () {\n      const cacheKey = `${source.getKey()}|${header.etag || \"\"}|${offset}|${length}`;\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = cacheValue.data;\n        return data;\n      }\n      const directory = yield getDirectory(\n        source,\n        this.decompress,\n        offset,\n        length,\n        header\n      );\n      this.cache.set(cacheKey, {\n        lastUsed: this.counter++,\n        data: directory\n      });\n      this.prune();\n      return directory;\n    });\n  }\n  // for v2 backwards compatibility\n  getArrayBuffer(source, offset, length, header) {\n    return __async(this, null, function* () {\n      const cacheKey = `${source.getKey()}|${header.etag || \"\"}|${offset}|${length}`;\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = yield cacheValue.data;\n        return data;\n      }\n      const resp = yield source.getBytes(offset, length, void 0, header.etag);\n      this.cache.set(cacheKey, {\n        lastUsed: this.counter++,\n        data: resp.data\n      });\n      this.prune();\n      return resp.data;\n    });\n  }\n  prune() {\n    if (this.cache.size > this.maxCacheEntries) {\n      let minUsed = Infinity;\n      let minKey = void 0;\n      this.cache.forEach((cacheValue, key) => {\n        if (cacheValue.lastUsed < minUsed) {\n          minUsed = cacheValue.lastUsed;\n          minKey = key;\n        }\n      });\n      if (minKey) {\n        this.cache.delete(minKey);\n      }\n    }\n  }\n  invalidate(source) {\n    return __async(this, null, function* () {\n      this.cache.delete(source.getKey());\n    });\n  }\n};\nvar SharedPromiseCache = class {\n  constructor(maxCacheEntries = 100, prefetch = true, decompress = defaultDecompress) {\n    this.cache = /* @__PURE__ */ new Map();\n    this.invalidations = /* @__PURE__ */ new Map();\n    this.maxCacheEntries = maxCacheEntries;\n    this.counter = 1;\n    this.decompress = decompress;\n  }\n  getHeader(source) {\n    return __async(this, null, function* () {\n      const cacheKey = source.getKey();\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = yield cacheValue.data;\n        return data;\n      }\n      const p = new Promise((resolve, reject) => {\n        getHeaderAndRoot(source, this.decompress).then((res) => {\n          if (res[1]) {\n            this.cache.set(res[1][0], {\n              lastUsed: this.counter++,\n              data: Promise.resolve(res[1][2])\n            });\n          }\n          resolve(res[0]);\n          this.prune();\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n      this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n      return p;\n    });\n  }\n  getDirectory(source, offset, length, header) {\n    return __async(this, null, function* () {\n      const cacheKey = `${source.getKey()}|${header.etag || \"\"}|${offset}|${length}`;\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = yield cacheValue.data;\n        return data;\n      }\n      const p = new Promise((resolve, reject) => {\n        getDirectory(source, this.decompress, offset, length, header).then((directory) => {\n          resolve(directory);\n          this.prune();\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n      this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n      return p;\n    });\n  }\n  // for v2 backwards compatibility\n  getArrayBuffer(source, offset, length, header) {\n    return __async(this, null, function* () {\n      const cacheKey = `${source.getKey()}|${header.etag || \"\"}|${offset}|${length}`;\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = yield cacheValue.data;\n        return data;\n      }\n      const p = new Promise((resolve, reject) => {\n        source.getBytes(offset, length, void 0, header.etag).then((resp) => {\n          resolve(resp.data);\n          if (this.cache.has(cacheKey)) {\n          }\n          this.prune();\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n      this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n      return p;\n    });\n  }\n  prune() {\n    if (this.cache.size >= this.maxCacheEntries) {\n      let minUsed = Infinity;\n      let minKey = void 0;\n      this.cache.forEach((cacheValue, key) => {\n        if (cacheValue.lastUsed < minUsed) {\n          minUsed = cacheValue.lastUsed;\n          minKey = key;\n        }\n      });\n      if (minKey) {\n        this.cache.delete(minKey);\n      }\n    }\n  }\n  invalidate(source) {\n    return __async(this, null, function* () {\n      const key = source.getKey();\n      if (this.invalidations.get(key)) {\n        return yield this.invalidations.get(key);\n      }\n      this.cache.delete(source.getKey());\n      const p = new Promise((resolve, reject) => {\n        this.getHeader(source).then((h) => {\n          resolve();\n          this.invalidations.delete(key);\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n      this.invalidations.set(key, p);\n    });\n  }\n};\nvar PMTiles = class {\n  constructor(source, cache, decompress) {\n    if (typeof source === \"string\") {\n      this.source = new FetchSource(source);\n    } else {\n      this.source = source;\n    }\n    if (decompress) {\n      this.decompress = decompress;\n    } else {\n      this.decompress = defaultDecompress;\n    }\n    if (cache) {\n      this.cache = cache;\n    } else {\n      this.cache = new SharedPromiseCache();\n    }\n  }\n  /**\n   * Return the header of the archive,\n   * including information such as tile type, min/max zoom, bounds, and summary statistics.\n   */\n  getHeader() {\n    return __async(this, null, function* () {\n      return yield this.cache.getHeader(this.source);\n    });\n  }\n  /** @hidden */\n  getZxyAttempt(z, x, y, signal) {\n    return __async(this, null, function* () {\n      const tileId = zxyToTileId(z, x, y);\n      const header = yield this.cache.getHeader(this.source);\n      if (header.specVersion < 3) {\n        return v2_default.getZxy(header, this.source, this.cache, z, x, y, signal);\n      }\n      if (z < header.minZoom || z > header.maxZoom) {\n        return void 0;\n      }\n      let dO = header.rootDirectoryOffset;\n      let dL = header.rootDirectoryLength;\n      for (let depth = 0; depth <= 3; depth++) {\n        const directory = yield this.cache.getDirectory(\n          this.source,\n          dO,\n          dL,\n          header\n        );\n        const entry = findTile(directory, tileId);\n        if (entry) {\n          if (entry.runLength > 0) {\n            const resp = yield this.source.getBytes(\n              header.tileDataOffset + entry.offset,\n              entry.length,\n              signal,\n              header.etag\n            );\n            return {\n              data: yield this.decompress(resp.data, header.tileCompression),\n              cacheControl: resp.cacheControl,\n              expires: resp.expires\n            };\n          }\n          dO = header.leafDirectoryOffset + entry.offset;\n          dL = entry.length;\n        } else {\n          return void 0;\n        }\n      }\n      throw Error(\"Maximum directory depth exceeded\");\n    });\n  }\n  /**\n   * Primary method to get a single tile bytes from an archive.\n   *\n   * Returns undefined if the tile does not exist in the archive.\n   */\n  getZxy(z, x, y, signal) {\n    return __async(this, null, function* () {\n      try {\n        return yield this.getZxyAttempt(z, x, y, signal);\n      } catch (e) {\n        if (e instanceof EtagMismatch) {\n          this.cache.invalidate(this.source);\n          return yield this.getZxyAttempt(z, x, y, signal);\n        }\n        throw e;\n      }\n    });\n  }\n  /** @hidden */\n  getMetadataAttempt() {\n    return __async(this, null, function* () {\n      const header = yield this.cache.getHeader(this.source);\n      const resp = yield this.source.getBytes(\n        header.jsonMetadataOffset,\n        header.jsonMetadataLength,\n        void 0,\n        header.etag\n      );\n      const decompressed = yield this.decompress(\n        resp.data,\n        header.internalCompression\n      );\n      const dec = new TextDecoder(\"utf-8\");\n      return JSON.parse(dec.decode(decompressed));\n    });\n  }\n  /**\n   * Return the arbitrary JSON metadata of the archive.\n   */\n  getMetadata() {\n    return __async(this, null, function* () {\n      try {\n        return yield this.getMetadataAttempt();\n      } catch (e) {\n        if (e instanceof EtagMismatch) {\n          this.cache.invalidate(this.source);\n          return yield this.getMetadataAttempt();\n        }\n        throw e;\n      }\n    });\n  }\n};\nexport {\n  Compression,\n  EtagMismatch,\n  FetchSource,\n  FileSource,\n  PMTiles,\n  Protocol,\n  ResolvedValueCache,\n  SharedPromiseCache,\n  TileType,\n  bytesToHeader,\n  findTile,\n  getUint64,\n  leafletRasterLayer,\n  readVarint,\n  tileIdToZxy,\n  zxyToTileId\n};\n"],"names":["compare"],"mappings":"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","x_google_ignoreList":[0,2]}